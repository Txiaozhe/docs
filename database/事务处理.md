# 事务处理 Transaction

* 事务处理：指作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全地不执行
* ACID特性
  * A   原子性：指事务包含的所有操作要么全部成功，要么全部失败回滚
  * C   一致性：指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态
  * I    隔离性：指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离
  * D  持久性：指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的
* 事务隔离性

​        当多个线程同时开启事务操作数据库中的数据时，数据库系统需进行格里操作，以保证各个线程获取数据的准确性，否则会发生以下问题：

* + 脏读：一个事务处理过程中读取了另一个未提交事务中的数据
  + 不可重复读：由于在查询的间隔期间另一个事务修改并提交了数据，该数据在一个事务范围内多次查询却返回了不同的值
  + 幻读：在一个事务中读取到别的事务插入的数据，导致前后不一致


* 隔离级别

| 隔离级别                   | 脏读   | 不可重复读 | 幻读   |
| ---------------------- | ---- | ----- | ---- |
| read uncommitted（未提交读） | 可能   | 可能    | 可能   |
| read committed（已提交读）   | 不可能  | 可能    | 可能   |
| repeatable read（可重复读）  | 不可能  | 不可能   | 可能   |
| serializable（可串行化）     | 不可能  | 不可能   | 不可能  |

* 锁

* * 一次封锁

    预防死锁，在方法的开始阶段已预先知道需要知道哪些数据并全部锁住，方法执行之后再全部解锁。由于在事务开始阶段并不知道具体会用到哪些数据，所以该方案不适合在数据库中使用

  * 两段锁

    将事务分成两个阶段：加锁阶段和解锁阶段

    * 加锁阶段：可进行加锁操作。读数据需要申请获取S锁（共享锁：其他事务可以继续加共享锁，但不能加其他锁）；写数据前需申请X锁（排他锁：其他事务不能获取任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续。
    * 解锁阶段：当事务释放一个锁后，事务进入解锁阶段，在该阶段进行解锁操作而不能进行加锁操作（该方法无法避免死锁，但可以保证事务调度的串行化）

# 在CockroachDB中进行事务处理

[Transaction in CockroachDb](https://www.cockroachlabs.com/docs/transactions.html)

[gorm](http://jinzhu.me/gorm/advanced.html#transactions)

